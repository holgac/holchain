let g:leader='g'
let mapleader = g:leader

" helper python3 functions {{{
" repeats the given a:command a:n times
function! Repeat(command, n)
python3 << EOF
import vim
import subprocess
cmd = vim.eval('a:command')
n = int(vim.eval('a:n'))
for _ in range(n):
  vim.command(cmd)
EOF
endfunction

" creates mapping for <leader>N<prefix> for command*n
function! RepeatN(prefix, command, ...)
python3 << EOF
import vim
leader = vim.eval('g:leader')
prefix = vim.eval('a:prefix')
cmdpre = "nnoremap " + leader
command = vim.eval('a:command')
beforecmd = vim.eval('get(a:, 1, "")')
if beforecmd:
  cmd = cmdpre + prefix + prefix + " " + beforecmd
  vim.command(cmd)
for i in range(1, 10):
  cmd = cmdpre + str(i) + prefix + " " + beforecmd
  for _ in range(0, i):
    cmd += command
  vim.command(cmd)
EOF
endfunction
" }}}

" general config {{{
syntax on
set tabstop=2 expandtab autoindent shiftwidth=2 hlsearch backspace=2
set ruler smartcase ignorecase
set viminfo+='1000,f1,:1000
set foldmethod=marker
set relativenumber number incsearch
set shell=/bin/bash\ --login
set shellcmdflag=-ic
nnoremap <leader>sn :noh<CR>
" dont use registers on x key
noremap x "_x
noremap X "_X
" filename
nnoremap <leader>sfn :let @" = expand("%:t")<CR>
" absolute path
nnoremap <leader>sfp :let @" = expand("%:p")<CR>
" get dir (path minus filename)
nnoremap <leader>sfd :let @" = expand("%:h")<CR>
" Open the same file in a new tab
nmap <leader>sot :let @h = expand("%:p")<CR>ge:e <C-r>h<CR>
" reload vimrc
nnoremap <leader>sso :so ~/.vimrc<CR>
" jk to escape
inoremap jk <esc>
inoremap <esc> <esc>:call HardModeEcho(g:HardMode_hardmodeMsg)<CR>a
" }}}

" colours {{{
hi Comment ctermfg=Cyan
" }}}

" plugin config {{{
execute pathogen#infect()
let g:HardMode_level = 'wannabe' 
tnoremap jk <Esc>
function! OnOptionSet()
  if &paste ==# "1"
    tunmap jk
    tunmap <C-w>j
  else
    tnoremap jk <C-w>N
    " to prevent hanging
    tnoremap <C-w>j <C-w>j
  endif
endfunction
call OnOptionSet()
augroup vimrc
  autocmd!
  autocmd VimEnter,BufNewFile,BufReadPost * silent! call HardMode()
  autocmd OptionSet * silent! call OnOptionSet()
augroup END
let NERDTreeIgnore=['\.d$[[file]]', '\.o$[[file]]', '\.out$[[file]]']
nnoremap <C-n> :NERDTreeToggle<CR>
nmap <silent> <Leader>w <Plug>(CommandT)
" }}}

" tab operations {{{
nnoremap <leader>e :tabedit<CR>
call RepeatN("t", ":tabnext<CR>")
call RepeatN("T", ":tabprevious<CR>")
call RepeatN("q", ":quit<CR>")
call RepeatN("y", ":tabnext<CR>", ":tabrewind<CR>")
" }}}

" pluginish operations {{{
python3 << EOF
import vim
import re
class PathFinder:
  @staticmethod
  def path_in_ff():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    first = line.split(' ')[0]
    elems = first.split(':')
    return (elems[0], elems[1], 1)

  @staticmethod
  def wordpos_under_cursor():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    # check if whitespace
    if len(line) is 0:
      return
    cchar = line[cur[1]]
    if cchar == ' ' or cchar == '\t':
      vim.current.buffer.append('wtf', cur[0])
      # TODO: throw
      return
    left = line[:cur[1]]
    right = line[cur[1]:]
    regex = '^([\w/\.\-]*).*$'
    leftw = re.match(regex, left[::-1]).groups()[0]
    rightw = re.match(regex, right).groups()[0]
    return (cur[0] - 1, len(left) - len(leftw), len(left) + len(rightw))

  @staticmethod
  def path_under_cursor():
    buf = vim.current.buffer
    data = PathFinder.wordpos_under_cursor()
    if data is None:
      return
    (linenum, start, end) = data
    line = buf[linenum]
    path = line[start:end]
    regex = '^:(\d+)(:(\d+))?'
    right = line[end:]
    (line, col) = (0, 0)
    res = re.match(regex, right)
    if res:
      line = int(res.groups()[0])
      if len(res.groups()) == 3 and res.groups()[2] is not None:
        col = int(res.groups()[2])
    return (path, line, col)


class RunUtils:
  keymaps = None

  @staticmethod
  def feed_keys(keys):
    vim.command(f'call feedkeys("{keys}")')

  @staticmethod
  def unset_keymaps():
    if RunUtils.keymaps:
      for (cmd, key, fn) in RunUtils.keymaps:
        vim.command(f'{cmd} <buffer> {key} :python3 {fn}<CR>')
      RunUtils.keymaps = None

  @staticmethod
  def set_keymaps(cmd_key_fn_tuples):
    RunUtils.keymaps = cmd_key_fn_tuples
    for (cmd, key, fn) in cmd_key_fn_tuples:
      vim.command(f'{cmd} <buffer> {key} :python3 {fn}<CR>')

  @staticmethod
  def set_autocmds(event_fn_pairs):
    vim.command('augroup rundata')
    vim.command('autocmd! rundata')
    for (event, fn) in event_fn_pairs:
        vim.command(f'autocmd rundata {event} * silent! python3 {fn}')
    vim.command('augroup END')


class RunData:
  def __init__(self):
    self.match_id = None
    self.winid = None
    self.path_fetcher = PathFinder.path_under_cursor
    self.wordpos_under_cursor = PathFinder.wordpos_under_cursor
    self.target_winid = vim.eval('win_getid()')
    self.target_bufnr = vim.eval('winbufnr(0)')
    self.hidden_setting = None
    self.is_preview_mode = False

  def prompt(self):
    vim.command('call inputsave()')
    try:
      cmd = vim.eval('input("$ ")')
    except KeyboardInterrupt:
      return
    vim.command('call inputrestore()')
    if len(cmd.strip(' ')) == 0:
      return
    self.open_window(cmd)

  def on_run(self):
    args = ' '.join(str(i) for i in vim.eval('a:000'))
    self.open_window(args)

  def open_window(self, runcmd):
    height = '15'
    vim.command('botright ' + height + 'new')
    vim.command('setlocal buftype=nofile bufhidden=hide noswapfile')
    vim.command('read !' + runcmd)
    vim.command('setlocal readonly nomodifiable')
    vim.command('call cursor(1,1)')
    RunUtils.set_autocmds([
      ('BufLeave', 'run_data.on_quit()'),
      ('CursorMoved', 'run_data.on_cursor_moved()'),
    ])
    RunUtils.set_keymaps([
      ('nnoremap', 'q', 'run_data.on_quit()'),
      ('nnoremap', ':', 'run_data.on_quit() and RunUtils.feed_keys(":")'),
      ('nnoremap', '<CR>', 'run_data.on_select()'),
      # ('nnoremap', 'p', 'run_data.on_preview()'),
    ])
    vim.command('highlight RunHover ctermfg=red cterm=underline,bold,italic')
    self.winid = vim.eval('win_getid()')
    self.on_cursor_moved()

  def on_quit(self):
    vim.command('quit')
    vim.command('call win_gotoid(' + self.target_winid + ')')
    self.cleanup()
    return True

  def on_cursor_moved(self):
    if self.match_id is not None:
      vim.command('call matchdelete({})'.format(self.match_id))
      self.match_id = None
    data = self.wordpos_under_cursor()
    if data is None:
      return
    (linenum, start, end) = data
    self.match_id = vim.eval(
      "matchaddpos('RunHover', [[{},{},{}]])".format(linenum + 1, start + 1, end - start),
    )

  def on_preview(self):
    data = self.path_fetcher()
    if data is None:
      return
    if self.hidden_setting is None:
      self.hidden_setting = bool(int(vim.eval('&hidden')))
      vim.command('set hidden')
    (path, cx, cy) = data
    self.open_file(path, cx, cy)
    RunUtils.set_autocmds([
      ('BufLeave', 'run_data.on_quit()'),
    ])

  def open_file(self, path, cx = None, cy = None):
    vim.command('call win_gotoid(' + self.target_winid + ')')
    vim.command('edit ' + path)
    if cx is not None and cy is not None:
      vim.command('call cursor(' + str(cx) + ', ' + str(cy) + ')')

  def focus_to_win(self):
    vim.command(f'call win_gotoid({self.winid})')
    return True

  def on_select(self, set_cursor = True):
    data = self.path_fetcher()
    if data is None:
      return
    (path, cx, cy) = data
    # close current window
    vim.command('quit')
    if set_cursor:
      self.open_file(path, cx, cy)
    else:
      self.open_file(path)
    self.cleanup()

  def cleanup(self):
    if self.hidden_setting is False:
      vim.command('set hidden')
    vim.command('augroup rundata')
    vim.command('autocmd! rundata')
    vim.command('augroup END')
    vim.command('highlight clear RunHover')

EOF

function! Run(...)
python3 << EOF
run_data = RunData()
run_data.on_run()
EOF
endfunction

function! RunPrompt()
python3 << EOF
run_data = RunData()
run_data.prompt()
EOF
endfunction

nnoremap <silent> <Leader>r :call RunPrompt()<CR>

command! -nargs=+ Run call Run("<args>")


" }}}

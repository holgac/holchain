let g:leader='g'
let mapleader = g:leader

" helper python3 functions {{{
" repeats the given a:command a:n times
function! Repeat(command, n)
python3 << EOF
import vim
import subprocess
cmd = vim.eval('a:command')
n = int(vim.eval('a:n'))
for _ in range(n):
  vim.command(cmd)
EOF
endfunction

" creates mapping for <leader>N<prefix> for command*n
function! RepeatN(prefix, command, ...)
python3 << EOF
import vim
leader = vim.eval('g:leader')
prefix = vim.eval('a:prefix')
cmdpre = "nnoremap " + leader
command = vim.eval('a:command')
beforecmd = vim.eval('get(a:, 1, "")')
if beforecmd:
  cmd = cmdpre + prefix + prefix + " " + beforecmd
  vim.command(cmd)
for i in range(1, 10):
  cmd = cmdpre + str(i) + prefix + " " + beforecmd
  for _ in range(0, i):
    cmd += command
  vim.command(cmd)
EOF
endfunction
" }}}

" general config {{{
syntax on
set tabstop=2 expandtab autoindent shiftwidth=2 hlsearch backspace=2
set ruler smartcase ignorecase
set viminfo+=:1000
set foldmethod=marker
set relativenumber number incsearch
set shell=/bin/bash\ --login
set shellcmdflag=-ic
nnoremap <leader>sn :noh<CR>
" dont use registers on x key
noremap x "_x
noremap X "_X
" filename
nnoremap <leader>sfn :let @" = expand("%:t")<CR>
" absolute path
nnoremap <leader>sfp :let @" = expand("%:p")<CR>
" get dir (path minus filename)
nnoremap <leader>sfd :let @" = expand("%:h")<CR>
" Open the same file in a new tab
nmap <leader>sot :let @h = expand("%:p")<CR>ge:e <C-r>h<CR>
" reload vimrc
nnoremap <leader>sso :so ~/.vimrc<CR>
" jk to escape
inoremap jk <esc>
inoremap <esc> <esc>:call HardModeEcho(g:HardMode_hardmodeMsg)<CR>a
" }}}

" colours {{{
hi Comment ctermfg=Cyan
" }}}

" plugin config {{{
execute pathogen#infect()
let g:HardMode_level = 'wannabe' 
tnoremap jk <Esc>
function! OnOptionSet()
  if &paste ==# "1"
    tunmap jk
    tunmap <C-w>j
  else
    tnoremap jk <C-w>N
    " to prevent hanging
    tnoremap <C-w>j <C-w>j
  endif
endfunction
call OnOptionSet()
augroup vimrc
  autocmd!
  autocmd VimEnter,BufNewFile,BufReadPost * silent! call HardMode()
  autocmd OptionSet * silent! call OnOptionSet()
augroup END
let NERDTreeIgnore=['\.d$[[file]]', '\.o$[[file]]', '\.out$[[file]]']
nnoremap <C-n> :NERDTreeToggle<CR>
nmap <silent> <Leader>r <Plug>(CommandT)
" }}}

" tab operations {{{
nnoremap <leader>e :tabedit<CR>
call RepeatN("t", ":tabnext<CR>")
call RepeatN("T", ":tabprevious<CR>")
call RepeatN("q", ":quit<CR>")
call RepeatN("y", ":tabnext<CR>", ":tabrewind<CR>")
" }}}

" pluginish operations {{{
python3 << EOF
import vim
import re
class PathFinder:
  @staticmethod
  def path_in_ff():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    first = line.split(' ')[0]
    elems = first.split(':')
    return (elems[0], elems[1], 1)

  @staticmethod
  def wordpos_under_cursor():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    # check if whitespace
    if len(line) is 0:
      return
    cchar = line[cur[1]]
    if cchar == ' ' or cchar == '\t':
      vim.current.buffer.append('wtf', cur[0])
      # TODO: throw
      return
    left = line[:cur[1]]
    right = line[cur[1]:]
    regex = '^([\w/\.]*).*$'
    leftw = re.match(regex, left[::-1]).groups()[0]
    rightw = re.match(regex, right).groups()[0]
    return (cur[0] - 1, len(left) - len(leftw), len(left) + len(rightw))

  @staticmethod
  def path_under_cursor():
    buf = vim.current.buffer
    data = PathFinder.wordpos_under_cursor()
    if data is None:
      return
    (linenum, start, end) = data
    line = buf[linenum]
    path = line[start:end]
    regex = '^:(\d+)(:(\d+))?'
    right = line[end:]
    (line, col) = (0, 0)
    res = re.match(regex, right)
    if res:
      line = int(res.groups()[0])
      if len(res.groups()) == 3 and res.groups()[2] is not None:
        col = int(res.groups()[2])
    return (path, line, col)


class RunData:
  def __init__(self):
    self.match_id = None
    self.target_winid = None
    self.path_fetcher = PathFinder.path_under_cursor
    self.wordpos_under_cursor = PathFinder.wordpos_under_cursor

  def open_window(self):
    self.target_winid = vim.eval('win_getid()')
    args = ' '.join(str(i) for i in vim.eval('a:000'))
    height = '15'
    vim.command('botright ' + height + 'new')
    vim.command('setlocal buftype=nofile bufhidden=hide noswapfile')
    vim.command('read !' + args)
    vim.command('setlocal readonly nomodifiable')
    vim.command('call cursor(1,1)')
    vim.command('noremap <buffer> q :call RunQuit()<CR>')
    vim.command('noremap <buffer> : :call RunQuit()<CR>:')
    # TODO: preview
    # vim.command('noremap <buffer> p :call PreviewClick()<CR>')
    vim.command('noremap <buffer> <CR> :call RunSelect()<CR>')
    vim.command('augroup rundata')
    vim.command('autocmd rundata BufLeave * silent! call RunQuit()')
    vim.command('autocmd rundata CursorMoved * silent! call RunCursorMoved()')
    vim.command('augroup END')
    vim.command('highlight RunHover ctermfg=red cterm=underline,bold,italic')
    self.on_cursor_moved()

  def on_quit(self):
    vim.command('quit')
    self.cleanup()

  def on_cursor_moved(self):
    if self.match_id is not None:
      vim.command('call matchdelete({})'.format(self.match_id))
      self.match_id = None
    data = self.wordpos_under_cursor()
    if data is None:
      return
    (linenum, start, end) = data
    self.match_id = vim.eval(
      "matchaddpos('RunHover', [[{},{},{}]])".format(linenum + 1, start + 1, end - start),
    )

  def on_select(self):
    data = self.path_fetcher()
    if data is None:
      return
    (path, cx, cy) = data
    # close current buffer
    vim.command('quit')
    vim.command('call win_gotoid(' + self.target_winid + ')')
    vim.command('edit ' + path)
    vim.command('call cursor(' + str(cx) + ', ' + str(cy) + ')')
    self.cleanup()

  def cleanup(self):
    vim.command('augroup rundata')
    vim.command('autocmd! rundata')
    vim.command('augroup END')
    vim.command('highlight clear RunHover')

EOF

function! Run(...)
python3 << EOF
run_data = RunData()
run_data.open_window()
EOF
endfunction

function! RunQuit()
python3 << EOF
run_data.on_quit()
EOF
endfunction

function! RunSelect()
python3 << EOF
run_data.on_select()
EOF
endfunction

function! RunCursorMoved()
python3 << EOF
run_data.on_cursor_moved()
EOF
endfunction

command! -nargs=+ Run call Run("<args>")


" }}}

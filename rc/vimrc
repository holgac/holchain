let g:leader='g'
let mapleader = g:leader

" helper python functions {{{
" repeats the given a:command a:n times
function! Repeat(command, n)
python << EOF
import vim
import subprocess
cmd = vim.eval('a:command')
n = int(vim.eval('a:n'))
for _ in xrange(n):
  vim.command(cmd)
EOF
endfunction

" creates mapping for <leader>N<prefix> for command*n
function! RepeatN(prefix, command)
python << EOF
import vim
leader = vim.eval('g:leader')
prefix = vim.eval('a:prefix')
cmdpre = "nnoremap " + leader
command = vim.eval('a:command')
for i in xrange(1, 10):
  cmd = cmdpre + str(i) + prefix + " "
  for _ in xrange(0, i):
    cmd += command
  vim.command(cmd)
EOF
endfunction
" }}}

" general config {{{
syntax on
set tabstop=2 expandtab autoindent shiftwidth=2 hlsearch backspace=2
set ruler smartcase ignorecase
set viminfo+=:1000
set foldmethod=marker
set relativenumber number incsearch
nnoremap <leader>sn :noh<CR>
" dont use registers on x key
noremap x "_x
noremap X "_X
" filename
nnoremap <leader>sfn :let @" = expand("%:t")<CR>
" absolute path
nnoremap <leader>sfp :let @" = expand("%:p")<CR>
" get dir (path minus filename)
nnoremap <leader>sfd :let @" = expand("%:h")<CR>
" Open the same file in a new tab
nmap <leader>sot :let @h = expand("%:p")<CR>ge:e <C-r>h<CR>
" reload vimrc
nnoremap <leader>sso :so ~/.vimrc<CR>
" jk to escape
inoremap jk <esc>
inoremap <esc> <esc>:call HardModeEcho(g:HardMode_hardmodeMsg)<CR>a
" }}}

" colours {{{
hi Comment ctermfg=Cyan
" }}}

" plugin config {{{
execute pathogen#infect()
let g:HardMode_level = 'wannabe' 
autocmd VimEnter,BufNewFile,BufReadPost * silent! call HardMode()
let NERDTreeIgnore=['\.d$[[file]]', '\.o$[[file]]', '\.out$[[file]]']
nnoremap <C-n> :NERDTreeToggle<CR>
nmap <silent> <Leader>r <Plug>(CommandT)
" }}}

" tab operations {{{
nnoremap <leader>e :tabedit<CR>
call RepeatN("t", ":tabnext<CR>")
call RepeatN("T", ":tabprevious<CR>")
call RepeatN("q", ":quit<CR>")
" }}}

" pluginish operations {{{
python << EOF
import vim
import re
class PathFinder:
  @staticmethod
  def path_in_ff():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    first = line.split(' ')[0]
    elems = first.split(':')
    return (elems[0], elems[1], 1)

  @staticmethod
  def path_under_cursor():
    buf = vim.current.buffer
    cur = vim.current.window.cursor
    line = vim.current.buffer[cur[0] - 1]
    # check if whitespace
    cchar = line[cur[1]]
    if cchar == ' ' or cchar == '\t':
      vim.current.buffer.append('wtf', cur[0])
      return
    left = line[:cur[1]]
    right = line[cur[1]:]
    regex = '^([\w/\.]*).*$'
    left = re.match(regex, left[::-1]).groups()[0]
    right = re.match(regex, right).groups()[0]
    path = left[::-1] + right
    return (path, 1, 1)


class RunData:
  def __init(self):
    self.target_winid = None
    self.path_fetcher = None

  def open_window(self):
    self.target_winid = vim.eval('win_getid()')
    args = ' '.join(str(i) for i in vim.eval('a:000'))
    height = '15'
    vim.command('botright ' + height + 'new')
    vim.command('setlocal buftype=nofile bufhidden=hide noswapfile')
    vim.command('read !' + args)
    vim.command('setlocal readonly nomodifiable')
    vim.command('call cursor(1,1)')
    vim.command('noremap <buffer> q :q<CR>')
    # TODO: preview
    # vim.command('noremap <buffer> p :call PreviewClick()<CR>')
    vim.command('noremap <buffer> <CR> :call RunSelect()<CR>')
    self.path_fetcher = PathFinder.path_under_cursor
    # TODO: prevent leaving the window

  def on_select(self):
    (path, cx, cy) = self.path_fetcher()
    print 'path: ', path
    # close current buffer
    vim.command('quit')
    vim.command('call win_gotoid(' + self.target_winid + ')')
    vim.command('edit ' + path)
    vim.command('call cursor(' + str(cx) + ', ' + str(cy) + ')')

run_data = RunData()
EOF

function! Run(...)
python << EOF
run_data.open_window()
EOF
endfunction

function! RunSelect(...)
python << EOF
run_data.on_select()
EOF
endfunction

command! -nargs=+ Run call Run("<args>")


" }}}
